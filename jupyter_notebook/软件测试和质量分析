1 软件测试技术
    可执行的测试（用测试样例去运行可执行代码段）
      测试样例设计
          黑盒测试，白盒测试，灰盒测试
2 测试包含一个系统或应用程序，子系统在特定条件（正常和不正常）下，执行操作，得到并评估结果
3 黑盒测试：测试人员不关注程序或系统内在结构，关注程序功能性（注：同义词，行为测试，不透明测试，紧密测试）
4 软件工程领域的黑盒测试中，测试人员只知道合法的输入和期望输出，程序如何实现不知道
5 例子：边界值测试，等价类测试，决策表测试，回归测试，随机测试，范围测试等
6 边界值测试的合法性是错误经常发生在输入变量的极端值；简言之，错误聚集在边界值附近
7 边界值测试的基本思想是：使用输入变量的min,min+,nom,max-.max等这几个类型的值，逐一测试
8 基本的边界值测试的技术的一般性体现在两个方面：变量的个数，范围的种类
9 范围的一般性依赖于变量本身的特性
10 变量的数量的一般性：对于一个有n个变量的函数，边界值测试执行4n+1个测试用例
11 考虑到实际意义，对一些非法输入应该不予理会，另一些则应该给出错误信息
12 健壮性测试时边界值测试的拓展：相比于之前的五个边界值测试样例（min,min+,nom,max-,max），我们额外考虑min-和max+这两种情况，此时对于n个输入变量的函数，健壮性测试需要6n+1个测试样例
13 最坏情况测试：测试样例中有超过一个的极端值，这个是边界值测试的父集，对于有N个输入变量的函数，需要5的n次方个测试样例
14 特殊值测试：可能是功能测试最广泛和实用形式
15 特殊值测试发生在测试人员使用个人的知识，（以前类似程序的）经验，关于软点信息去设计测试样例
16 随机测试：随机使用所有可能的输入值的一个子集去测试程序或系统，作为一个附加的测试技术，不是最优的测试技术，很难检测很多问题
17 积极和消极测试：积极测试就是使用有效的输入，消极测试就是使用无效的输入。积极和消极测试是一种可输入的测试技术，需要可执行的有效和无效输入的均衡。一般，80%消极测试，20%积极测试
18 范围测试：假设在一定范围内的输入值，输出结果不变。在某个范围任意选取一个值，测试通过了就视为该范围内的值都通过了
19 回归测试：根据在开发螺旋，调试，维护，发布新版本做出的更改来测试应用程序。系统性能提升或修复所作出的更改，需要验证这些修改没有意外的副作用。简言之，就是修复bug或提升性能所作出的更改对系统不会有额外的影响。
20 等价类测试：从需求出发，每个输入被划分为不同部分（称之为类），从每个类中选择一个值来测试。使用等价类测试作为功能测试的基础的优势：测试的全面性，高效性。
21 等价类测试的关键是：等价关系的选择（决定了等价类的划分）；假设：类中的任意一个值可以代表这个类中的所有值
22 等价类测试还分为：弱一般等价类（每个类中只选择一个值作为测试样例intervals），强一般等价类（从等价类中选取值构成笛卡尔积，覆盖所有等价类，有可能输入组合中的一个，合法输入的范围划分的各个部分都有一个取值），弱健壮等价类（对于有效输入，从每个等价类中选择一个值；对于无效输入，测试样例有一个无效的值和保留的值将会有效，在坐标上表示为在x轴或y轴上划分的各部分只有一个值参与测试），强健壮等价类（在二维坐标系中划分的多个格子里，均有取值）
23 基于决策表的测试：在所有的功能测试中，基于决策表的测试是最严格的，因为它有强制逻辑分析，适用于分支很多的情况（此处还需要多看看）
24 白盒测试基于程序逻辑或执行路径，测试人员知道程序内在结构和逻辑
25 DD-Path（决策到决策-路径）：语句序列（从决策声明的行进开始到下一个决策的进行中结束），序列中没有内在分支，序列第一行代码执行，后续代码都会执行；路径链中，初始节点和终止节点不同，每个内在节点的出入度均为1，链的长度是箭头个数
26  语句覆盖测试：确保程序图中的每个节点至少执行一次（测试样例的个数由迭代条件中最多条件分支数确定）。
27 DD-Path测试：确保DD-Path图中的每一条边至少经过一次
28 循环覆盖测试：测试进入循环和跳出循环的条件，对循环的下标采用边界值测试
29 基路径测试：不允许迭代，可以跑完程序的逻辑或流路径
30 逻辑模块基本上包含了产品控制方面的决策流程。逻辑模块通常是位于模块互连图的根部附近的逻辑模块。另一方面，操作模块执行产品的实际操作
31 上下测试：在高层次模块或系统组件首先被集成和测试不断增加的方法，分级执行到底层的方法。需要创建stubs，stub是一个空模块，是一个模拟被调用单元的丢弃代码
32 当一个模块或系统组件正在被测试，通过stub来调用模块或组件，将控制返回给正在被调用的模块或系统组件带有一个模拟值。随着测试过程的向下深入，每一个stub被它所展示的真实代码所替代。每一轮测试属于同一层的某块或系统组件，不断向下深入
33 低高测试：低层次的模型或系统组件首先被集成和测试，这个过程是不断增加的，分级执行到顶层的测试。需要一个驱动或临时测试程序，关于测试模块和系统组件
34 一个驱动是一个调用当前测试模块一次或多次的模块，如果可能的话，检查在测试的模块下的返回值。从低至上的测试从底层模块开始测试，首先测试最底层的各个模块，然后是他们的上一层模块，不断重复，直到根节点
35 自底向上和自上到下顺序刚好相反（成镜像），两者对比：
    自顶向下的优势：能够发现顶层程序的设计错误，需要创建stubs，但比驱动创建简单
    自底向上的优势：尝试用于大型复杂的系统，操作模块全部被测试
    自顶向下的劣势：低层次模块测试的次数比高层次模块测试少得多，重复使用的模块可能没有充分被测试
   自底向上的劣势：系统可视化周期长，主要设计错误发现很晚，因为逻辑错误最后被测试
   ，驱动的创建较麻烦，而且可能增加额外的错误
36 三明治测试：同时使用自顶向下和自底向上测试，从顶部和底部同时开始测试，在某一时刻在层次的控制结构上相遇。逻辑模块被集成和自顶向下测试，操作模块被集成和自底向上测试。依次测试两组模块的接口。常在大型程序中使用
37 功能化测试和结构化测试的比较：
    功能化测试的优点：黑盒测试的一个主要优点是测试是面向程序或系统能做什么，这是能被任何人很自然的理解的，测试人员不需要实现方面的知识包括具体的编程语言。测试人员和编程人员是独立的，从用户角度测试；有助于找到规范中任何歧义或者不规范之处。一旦规范确定了，测试样例就可以设计了。
    功能化测试的缺点：实际上只测试了一小部分的可能的输入；由于不了解内在的结构或逻辑，程序中可能有错误或者程序员的恶作剧，这些事可能不被黑盒测试监测到；没有明确，具体的规范，测试样例很难设计。很多程序路径可能没有被测试。
    结构化测试的优点：促使测试开发者仔细考虑实现，发现隐藏在代码中错误，由于找到程序内在的结构和逻辑，错误或者程序员恶作剧有很大的可能被发现，有益的副作用
    结构化测试的缺点：不能确保规范的正确性，只是关注了代码的内在逻辑。不能发现路径丢失和敏感数据错误，由于测试样例有限，不能执行所有可能的程序路径，花费高
38 灰盒测试：结合黑盒测试和白盒测试的优点，测试人员研究需求说明书和开发人员交流了解系统的内在结构。动力是清除模糊的规范，逐行阅读去设计隐含测试。例子：当测试人员发现一个确切的功能在一个程序中重复使用，如果测试者和开发人员交流了解了内在设计和结构，很多测试将会淘汰，因为这可能只是测试了一次那个功能。
39 软件测试的两个原因：判断软件质量和可用性，发现程序的问题
40 软件测试的时间：1在需求阶段，需求必须被检查 2在详细审查阶段，必须检查程序功能 3软件管理计划必须进行类似的详细审查 4设计阶段需要在每一个阶段认真检查 5通过验收测试后，产品被安装，开始维护阶段
41 测试是：软件周期的一个完整组件，软件质量管理的一个重要元素，软件开发生命周期必须执行的一个活动。
42 测试的类型：可执行测试，不可执行测试
43 可执行测试的限制：当测试发生时，测试不能检查所有的情况，实际上测试所有软件是不可能的，详尽的测试代码是不实际的。
44 执行已经写好的详细说明书是不可能的，唯一可做的就是尽可能小心的回顾它
45 需求阶段经常是引入50%以上缺陷的地方
46 评审的范围从非常非正式的同行评审到非常正式和结构化的检查。包括：检查，走查，同行评审
47 检查由3-6人的团队组成。例子：在设计检查阶段，团队由：管理员（管理者和检查组的领导），设计人员，实现人员，需求分析师，测试人员。
48 检查的输入是：检查文档，相关的资源文档，一般和特制的检查清单
      输出是：检查总结或报告，错误类型数据
49 检查的步骤是：概述（由制作该文件的人员对要检查的文档进行概述（规范，设计，代码和计划），概述阶段结束后，文档被分发给参与人员），准备（参与人员尝试细节地了解文档，在最近的检查中找到的检查清单或标注了频数的错误类型等级的错误类型清单是不错的做法，这些检查清单帮助团队成员集中在大部分错误发生的地方），检查（一个团队成员走查文档和检查小组，确保覆盖了每一个细节和每一个分支至少被执行一次，随着走查的进行，目的是找到和记录错误，而不是纠正这些错误，在检查会议上的主持人理想情况下不是被检查文件的制作人或作者。），返工（检查组的领导一天内必须制作一个手写的检查报告确保细致贯彻，负责该文件的人解决所有人错误和问题出现在书面报告中），跟进（领导者必须确保通过修复文件或澄清错误地标记错误的项目，令所有提出的问题得到满意的回复。所有的修复必须确保没有新的错误产生）
50 检查的一个必要组件是潜在错误的检查清单；检查的一个重要组件是故障统计的记录；数据表明检查是错误发现的一个强大和成本效益工具
51 走查：可以是非常不正式或者相当不正式，但相较于检查，正式程度较低。一个不正式的走查可以是一个不正式的评估或信息目的的会议。经常需要很少或者没有准备。走查可以用作回顾系统开发可交付成果，包括逻辑或详细设计说明书，测试计划，测试样例以及代码
52 走查成员（2-7）：例子：一个需求详细说明走查小组：需求分析师（至少一个，代表团队的负责制定规范的），负责规范的管理者，一个客户代表，开发人员（执行下一阶段开发的），QA（软件质量确保小组）
53 走查团队的成员应该是尽可能经验丰富的高级技术人员，因为他们更有可能找到重要的缺陷。走查应该由SQA代表担任主席，因为SQA代表如果演练表现不佳并且故障会因此滑落而损失最大。走查应该在两个小时以内完成
54 走查输入：正在检查的元素，走查的目的，适用标准；输出是报告
55 走查步骤：准备和走查；走查的材料必须提前发给参与者以便进行认真的准备，每一个参与者应该研究那些材料和制作两个清单：一个参与者不理解的，一个是参与者认为不正确的
56 开展走查的两种方式：参与驱动（参与者展示他们不理解和不正确的东西的清单，规范团队的代表必须对每一个提问进行回复，解释参与者不理解的和要么承认确实存在这样的错误要么解释为什么参与者错误理解了）和文档驱动（负责文档的人员通过该文档向参与者介绍，审阅者通过他们准备的评论或由演示文稿触发的评论进行中断。文档驱动通常会导致检测到更多故障，因为文档驱动的走查中的大多数故障都由演示者自发检测）
57 走查优势：审查人员的高级准备不是必要需求，可以频繁开展走查，结构化走查是一种非常有效的发现代码中错误的方法
  走查劣势：可能导致杂乱无章的检查，开展走查时开发人员可能很焦虑
58 代码走查的指导方针：
    1 由项目经理或首席程序员主持审核会议，负责安排会议，预定会议室，确定议程，邀请参与者等。
    2 程序员将他或她的工作呈现给审阅者。在演示过程中讨论应该是一般性的。
    3 随着一般性的讨论，编程人员细节地走查代码，集中在代码的逻辑而不是在具体的测试样例
    4 审阅者请求走查具体的测试样例
    5 如果审核小组之间不能达成一致意见，主席通常会向程序员分配职责，以便作出具体更改，主席将解决分歧。
    6 如果需要，确定第二轮的走查
59 检查和走查的比较：
    走查是一个两步的过程和检查是一个五步的过程。检查过程花费的时间比走查长的多。
    检查小组使用检查清单帮助找到错误，进行的程度比走查深
    走查比检查包含更多的材料，他们为大量人熟悉材料提供一个机会。检查经常处理相对较少得材料
    偶尔，走查是为了交流而不是发现错误
60 同行检查：只是简单地给别人发一份文件，并要求他们仔细观察这些文件，就会发现我们自己可能找不到的缺陷。
61 测试的目的：增加开发生命周期的有效性，提高软件产品的质量。  质量控制技术
62 代码检查的错误清单：1数据引用错误 2数据声明错误 3运算错误 4比较错误 5控制流程错误 6接口错误 7输入输出错误 8其他检查
63 软件开发过程中的五个常见问题：详细需求，明确时间表，充分测试，尽可能坚持原来的需求，交流
不能很好的理解用户的需求，缺少与用户之间的沟通。错误的预估项目的大小和难易度。没有计划就匆匆开始编码。没有在项目初期就开始做测试，一直拖到项目后期才做，或者根本不做什么测试。拖延计划，把进度压力留在后期。不做版本控制，混乱的代码库和开发环境。
64 质量的含义：质量意味着满足需求，产品或服务是否满足客户需求，换句话说就是质量就是适合使用
65 预防和检测：检测首先意味着预防质量缺陷，通过质量管理计划使产品和过程可评估，预防减少产品费用因为缺陷的定位和纠正将会减少在将来修复这个缺陷的费用，最大的回报就是预防
66 核实/验证和确认：  核实的总体目标是确保在整个软件生命开发周期内每一个产品的的发展来满足用户的需求和在软件需求文档中指定的目标。发生在让整个软件生命周期
    确认检查的是系统在生命周期的末期是否满足顾客的需求。发生在软件交付之前。
  提示：一个好的方法是结合核实和确认在测试过程中。
67 质量保证意味着花费，这个数字经常不低。质量成本包括追求质量或执行质量相关活动所产生的所有成本。包含以下四方面的费用：预防费用（包括为防止缺陷发生而采取的行动。质量计划，正式技术评论，测试设备，训练），鉴定费用（包括测量，评估，审计产品或服务来符合标准和规范，检查和测试产品，设备校准和维护，处理和报告检查的数据），内部故障成本（用户得到产品前发生在修复缺陷产品的费用，返工，修复，失效模式分析），外部故障成本（产品发布后修复发现的缺陷的费用，投诉决议，产品退货和更换，在线帮助支持，保修工作，未来商业损失）
68 软件产品：定义：计算机软件是产品，软件工程设计和构建
  工作产品：定义：从软件工程角度看，软件是由程序，数据和文档组成的。从用户角度看，工作产品是以某种方式使用户的世界变得更好的结果信息。软件工程的目的是提供一个构建更高质量软件的框架。
69 软件开发过程：当您建立产品或系统时，重要的是要经过一系列可预测的步骤 - 一张路线图，帮助您创建及时，高质量的结果。您遵循的路线图称为“软件过程”。软件过程被定义为构建高质量软件所需的任务的框架。