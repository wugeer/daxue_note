算法描述：
    １扫描Ｄ，得到频繁项(１项集)的集合和相应的支持度计数，去掉小于最小支持度计数那些项，按倒序排列
    ２将Ｄ的所有事务的项按１得到的倒序排列进行排列，那些支持度小于最小支持度阈值的项忽略
    ３构造FP树:首先构造一个null节点作为根节点，将２中事务的项的排列，从根节点开始延伸，如果前面几个项相同，那么那几个项计数＋１，可以这么考虑，将每个事务当做一根绳子，如果绳子的头相同，那么可以重用那些节点
    ４挖掘FP树：从每个叶子节点开始考虑，得到根到叶子的路径，从叶子节点往根节点开始考虑，删除不满足最小支持度阈值的项，剩余的项集作为一个挖掘项集，可以得到一元项集，二元项集，。。。，也就是项集中的项的组合构成挖掘项集
    