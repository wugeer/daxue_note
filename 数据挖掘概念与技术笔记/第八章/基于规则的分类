１使用if-then规则分类
    规则是表示信息或少量知识的好方法。基于规则的分类器使用if-then规则进行分类。形式为：if 条件 then 结论
    规则Ｒ可以用它的覆盖率和准确率来评估。覆盖率是规则覆盖的元组的百分比，准确率是覆盖的元祖中正确分类的元组的百分比。
    考虑多个规则被触发，解决方法：
        １规模序
            把最高优先权赋予具有最苛刻要求的被触发的规则，其中苛刻性用规则前件的规模来度量。即，激活具有最多属性测试的被触发的规则。规则总体是无序的
        ２规则序
            预先确定规则的规则的优先次序，这种序可以是基于类或规则的。使用基于类的序，类按重要性递减排序。也可以根据每个类的误分类代价排序；使用基于规则的序，根据规则质量的度量，如准确率，覆盖率，规模或者根据领域专家的建议，把规则组织成一个优先权列表，大部分基于规则的分类系统都是使用基于类的规则序策略。
    考虑到不存在Ｘ满足规则的情况，建立一个缺省或默认规则，根据训练集指定一个默认类，可以是多数类，或者不被任何规则覆盖的元祖的多数类。

２由决策树提取规则
    　其实特别简单，就是对每条从根到树叶节点的路径创建一个规则，沿着路径上的每个分裂准则的逻辑AND形成规则的前件，存放类预测的树叶节点形成规则后件。所提取的规则是互斥的和穷举的，不需要默认规则，无序
     修建规则集，对于给定的规则前件，不能提高规则的估计准确率的任何条件都可以剪掉，从而泛化该规则

3使用顺序覆盖算法的规则归纳
    算法的一般策略为：一次学习一个规则，每学习一个规则，就删除该规则覆盖的元组，并在剩下的元组上重复该过程。追求高准确率，不追求高覆盖率。
    对每一个类，一次学习一个规则，每学习一个规则，就删除该规则覆盖的元组，并在剩下的元组上重复该过程。
    典型地，规则以从一般到特殊的方式增长。从空规则开始，逐渐向他添加属性测试，添加的属性测试作为规则前件中的逻辑合取AND。每当面临添加一个新的属性测试，根据训练样本选择最能提高规则质量属性的测试。为了更加鲁棒，每一步维持k个最佳候选。
    规则质量度量：主要考察的几种度量，熵（倾向于类大小相差较大的情况），基于信息增益的度量（在一阶归纳学习器中，主要用到的概念为用于学习规则的类的元组称为正元组，其余元组为负元组，设pos(neg)为被R覆盖的正(负)元组数，pos‘(neg’)为被R‘覆盖的正(负)元组数，使用的估计公式为：FOIL_Gain=pos'*(log2(pos'/(pos'+neg'))-log2(pos/(pos+neg))),该公式偏向于具有较高准确率并且覆盖许多正元组的规则），考虑覆盖率的统计校验（使用似然率估计Likelihood_Ratio=类i的观测频率乘以log(类i观测频率除以类i期望频率)的乘积的求和，结果再乘以2,，该统计量服从自由度为m-1的卡方分布，似然率越高，规则越无效）。
    规则剪枝：剪枝的目的是剪枝后的版本有更高的质量。被剪掉的元组集称为剪枝集，FOIL的剪枝策略，给定规则R，FOIL_Prune(R)=(pos-neg)/(pos+neg),其中pos,neg分别是规则R覆盖的正元组数和负元组数，这个值随着R在剪枝集上的准确率的增加而增加。如果R剪枝后的版本的FOIL_Prune值较高，则对R剪枝。一个规则好不好一个很简单的思路就是该规则覆盖的正负元组比例越大越好。